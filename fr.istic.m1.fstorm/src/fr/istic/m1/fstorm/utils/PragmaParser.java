package fr.istic.m1.fstorm.utils;

import java.util.ArrayList;
import java.util.List;

import fr.istic.m1.fstorm.FStormPragma;
import fr.istic.m1.fstorm.InvalidPragmaSyntaxException;
import fr.istic.m1.fstorm.PragmaLexicalUnit;
import fr.istic.m1.fstorm.beans.ComponentPragma;
import fr.istic.m1.fstorm.beans.TupleReturnPragma;

/**
 * This class encapsulate the parser for a Java type.
 * @author Kévin Le Bon
 */
class JavaTypeParser {
	/**
	 * Function that parses a type with its package name before it (ex: java.util.List). Every type is namespaced.
	 * @param lexer the token list.
	 * @return the String representation of the parsed type.
	 * @throws InvalidPragmaSyntaxException
	 */
	public static String parseNamespacedType(List<PragmaLexicalUnit> lexer) throws InvalidPragmaSyntaxException {
		String returnType = "";
		
		if(!lexer.isEmpty() && lexer.get(0).isIdentifier()) {
			returnType += lexer.get(0).getValue();
			lexer.remove(0);
			
			if(!lexer.isEmpty() && lexer.get(0).isSymbol(".")) {
				returnType += ".";
				lexer.remove(0);
				returnType += parseNamespacedType(lexer);
			}
			
			else
				returnType += parseGenericType(lexer);
		}
		
		else
			throw new InvalidPragmaSyntaxException("expected an identifier");
		
		return returnType;
	}

	/**
	 * Function parsing the parameters of a generic type.
	 * @param lexer the token list.
	 * @return the String representation of the parameters of a generic type.
	 */
	private static String parseGenericType(List<PragmaLexicalUnit> lexer) throws InvalidPragmaSyntaxException {
		String returnType = "";
		
		if(!lexer.isEmpty() && lexer.get(0).isSymbol("<")) {
			lexer.remove(0);
			returnType += "<" + parseNamespacedType(lexer);
			
			while(!lexer.isEmpty() && lexer.get(0).isSymbol(",")) {
				lexer.remove(0);
				returnType += "," + parseNamespacedType(lexer);
			}
			
			if(lexer.isEmpty() || !lexer.get(0).isSymbol(">"))
				throw new InvalidPragmaSyntaxException("expected symbol \">\"");
			returnType += ">";
			lexer.remove(0);
		}
		
		return returnType + parseArray(lexer);
	}

	/**
	 * Function that parses the brackets of an array.
	 * @param lexer the token list.
	 * @return the brackets of the parsed array.
	 */
	private static String parseArray(List<PragmaLexicalUnit> lexer) {
		String returnType = "";
		
		while(lexer.size() >= 2 && lexer.get(0).isSymbol("[") && lexer.get(1).isSymbol("]")) {
			returnType += "[]";
			lexer.remove(0);
			lexer.remove(0);
		}
		
		if(!lexer.isEmpty() && lexer.get(0).isSymbol("["))
			throw new InvalidPragmaSyntaxException("excepted symbol \"]\"");
		
		return returnType;
	}
}

/**
 * This class encapsulates the parser for fstorm-pragma syntax.
 * @author Kévin Le Bon
 */
public class PragmaParser {
	/**
	 * Function that parses a whole fstorm pragma.
	 * @param tokenList the token list generated by the lexer.
	 * @return the generated pragma object.
	 * @throws InvalidPragmaSyntaxException
	 */
	public static FStormPragma parsePragma(List<PragmaLexicalUnit> tokenList) throws InvalidPragmaSyntaxException {
		List<PragmaLexicalUnit> lexer = tokenList; // copy list
		
		if(!lexer.isEmpty() && lexer.get(0).isIdentifier("fstorm")) {
			lexer.remove(0);
			
			if(lexer.isEmpty() || !lexer.get(0).isIdentifier())
				throw new InvalidPragmaSyntaxException("expected identifier \"spout\", \"bolt\", \"hls\" or \"HLS\"");
			else {
				switch(lexer.get(0).getValue()) {
					case "spout":
						lexer.remove(0);
						return parseSpout(lexer);
					case "bolt":
						lexer.remove(0);
						return parseBolt(lexer);
					case "tuple":
						return new TupleReturnPragma();
					default:
						throw new InvalidPragmaSyntaxException("expected identifier \"spout\", \"bolt\", \"hls\" or \"HLS\"");
				}
			}
		}
		
		// Not a fstorm pragma. 
		return null;
	}
	
	/**
	 * Function parsing a bolt.
	 * @param lexer the token list.
	 * @return the newly generated bolt.
	 * @throws InvalidPragmaSyntaxException
	 */
	private static FStormPragma parseBolt(List<PragmaLexicalUnit> lexer) throws InvalidPragmaSyntaxException {
		List<String> paramTypes = new ArrayList<String>();
		String returnType = "void";
		
		if(!lexer.isEmpty() && lexer.get(0).isSymbol("("))
			paramTypes = parseParamList(lexer);
		else
			throw new InvalidPragmaSyntaxException("expected parameter list");

		if(!lexer.isEmpty() && lexer.get(0).isIdentifier("returns"))
			returnType = parseReturns(lexer);
		
		return ComponentPragma.createNewBolt(paramTypes, returnType);
	}

	/**
	 * Function parsing a Java typename.
	 * @param lexer the token list.
	 * @return the parsed typename
	 * @throws InvalidPragmaSyntaxException
	 */
	private static String parseJavaType(List<PragmaLexicalUnit> lexer) throws InvalidPragmaSyntaxException {
		if(lexer.isEmpty() || !lexer.get(0).isIdentifier())
			throw new InvalidPragmaSyntaxException("expected Java type");
		String classname = JavaTypeParser.parseNamespacedType(lexer);
		
		return classname;
	}
	
	/**
	 * Function parsing the list of parameter types of a spout or a bolt.
	 * @param lexer the token list.
	 * @return the list of parameter types.
	 * @throws InvalidPragmaSyntaxException
	 */
	private static List<String> parseParamList(List<PragmaLexicalUnit> lexer) throws InvalidPragmaSyntaxException {
		// Syntax : ('JavaType', 'JavaType...')
		List<String> paramList = new ArrayList<String>();
		
		if(lexer.isEmpty() || !lexer.get(0).isSymbol("("))
			throw new InvalidPragmaSyntaxException("expected symbol \"(\"");
		lexer.remove(0);
		
		paramList.add(parseJavaType(lexer));
		
		while(!lexer.isEmpty() && lexer.get(0).isSymbol(",")) {
			lexer.remove(0);
			paramList.add(parseJavaType(lexer));
		}
		
		if(lexer.isEmpty() || !lexer.get(0).isSymbol(")"))
			throw new InvalidPragmaSyntaxException("expected symbol \")\"");
		lexer.remove(0);
		
		return paramList;
	}
	
	/**
	 * Function parsing the "returns" clause of a Storm-component pragma.
	 * @param lexer the token list.
	 * @return the parsed return type.
	 * @throws InvalidPragmaSyntaxException
	 */
	private static String parseReturns(List<PragmaLexicalUnit> lexer) throws InvalidPragmaSyntaxException {
		// Syntax : returns('JavaType')
		if(lexer.isEmpty() || !lexer.get(0).isIdentifier("returns"))
			throw new InvalidPragmaSyntaxException("expected keyword \"returns\"");
		lexer.remove(0);
		
		if(lexer.isEmpty() || !lexer.get(0).isSymbol("("))
			throw new InvalidPragmaSyntaxException("expected symbol \"(\"");
		lexer.remove(0);
		
		String returnType = parseJavaType(lexer);
		
		if(lexer.isEmpty() || !lexer.get(0).isSymbol(")"))
			throw new InvalidPragmaSyntaxException("expected symbol \")\"");
		lexer.remove(0);
		
		return returnType;
	}
	
	/**
	 * Function parsing a spout.
	 * @param lexer the token list.
	 * @return the parsed spout.
	 * @throws InvalidPragmaSyntaxException
	 */
	private static FStormPragma parseSpout(List<PragmaLexicalUnit> lexer) throws InvalidPragmaSyntaxException {
		return ComponentPragma.createNewSpout(parseReturns(lexer));
	}
}
